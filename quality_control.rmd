---
title: 'GWAS tutorial: Data formats, summary statistics, and quality control'
author: Patrick Breheny and Tabitha Peter 
date: '`r format(Sys.Date(), "%B %d, %Y")`'
editor_options: 
  chunk_output_type: console
---

```{r knitr_setup, include=FALSE, purl=FALSE}
library(knitr)
library(kableExtra)
set.seed(1)
knitr::opts_knit$set(aliases=c(h = 'fig.height', w = 'fig.width'))
knitr::opts_chunk$set(comment="#", message=FALSE, collapse=TRUE, cache=FALSE, tidy=FALSE, fig.align="center")
knitr::knit_hooks$set(small.mar = function(before, options, envir) {
  if (before) par(mar = c(4, 4, .1, .1))
})
```

`R` packages we need to get started 

```{r}
library(data.table)
library(dplyr)
library(ggplot2)
```


Throughout, I'm going to use the `data.table` package to read in and work with data frames; feel free to use something else. With one exception, the files are just white space delimited text files, anything can open them.

# Getting the data

This tutorial will use data from the PennCATH study of genetic risk factors for coronary artery disease. Download the data from one of the following sources (the contents are the same):

- [Data (zip)](https://d1d95ugxcvloeo.cloudfront.net/penncath.zip): Windows
- [Data (tar)](https://d1d95ugxcvloeo.cloudfront.net/penncath.tar.gz): Mac/Linux

Download and unzip/untar the data; you can read the paper as well if you wish:

* [Paper](http://www.ncbi.nlm.nih.gov/pubmed/21239051)

In what follows, I will assume that the unzipped data files are in a folder called `data`; if you store them somewhere else, change the directory references.

# File formats

The data are given in "PLINK" format, which is the most common format for chip-based GWAS data (as of this writing). `PLINK` is an open-source whole genome association analysis toolset designed to perform a range of basic large-scale analyses in a computationally efficient manner. As part of the toolset, PLINK has its own file formats -- again, these have become the standard format in the GWAS field. Data stored in PLINK format come in 'bundles' -- that is, a PLINK data set consists of a set of files, not just one data file. It is worth knowing how to use the PLINK command line tool to analyze data in these files, but those with no experience on the command line may find that a daunting place to begin. Thankfully, we can also interface with `PLINK` via `R`. The package we will use for this is [bigsnpr](https://privefl.github.io/bigsnpr/).

Let's take a look at the PLINK file structure, examining what information is stored in each file. 

Among the zipped files are three that are necessary to perform a GWAS, the `.bed`, `.bim`, and `.fam` files.

## `.fam`

This contains information on the subjects:

```{r fam}
head(fam <- fread('data/penncath.fam'))
```

There are 1401 rows, one for each subject. The six colums are:

1. Family ID
2. Individual ID
3. Paternal ID
4. Maternal ID
5. Sex (1=male; 2=female; other=unknown)
6. Phenotype

In this data set, columns 2-4 are unimportant. In general, they are used to specify pedigrees (e.g., subject 3 is the daughter of subjects 1 and 2). In this study, however, none of the subjects are related, so the only column that is important is the first, which records the subject's unique ID.

Phenotype is typically used to record case-control status or something like that, but it is also quite common to just record clinical/biological information in a separate spreadsheet, which is what was done here.

```{r clinical}
(clinical <- fread('data/penncath.csv'))
```

As you can see, we've got the `FamID` to match this spreadsheet up with the genetic data, the disease status (`CAD=1` means that the subject has coronary artery disease), and some covariates (age, triglycerides, HDL and LDL cholesterol levels).

## `.bim`

The `.bim` file, by contrast, contains information on the genetic loci (SNPs):

```{r bim}
(bim <- fread('data/penncath.bim'))
```

As you can see, we have `r nrow(bim)` rows here, one for each SNP measured in the study. The columns are:

1. chromosome (1-22, X, Y or 0 if unplaced)
2. rs# or snp identifier
3. Genetic distance (morgans)
4. Base-pair position (bp units)
5. Allele 1 (usually minor allele, or 'effect' allele)
6. Allele 2 (usually major allele)

It is pretty common for column 3 to be ignored, as it is here. Many common analyses do not require base-pair position. 

So, for example, the file tells us that genetic locus rs12565286 is located 721290 bases into chromosome 1, and that most people have a C there, but some have a G. Of course, "most people" will be relative to a population -- be sure to confirm with collaborators that you have a correct understanding of which allele is considered 'minor', and what population(s) are described in the data. More on the idea of 'population structure' to come in a later module. 

## `.bed`

Finally, the `.bed` file, which has all the data. This is by far the largest of the three files, as it contains the entire `r nrow(fam)` by `r nrow(bim)` matrix of genotype calls for every subject and every locus. To keep things manageable, this file is encoded in a special binary format -- i.e., you can't just open the file in a text editor or load it with something like `r data.table::fread()`. That said, we can convert our PLINK data into a `bigSNP` object (defined in `bigsnpr`) -- this will let us look at our data in our `R` session. 


```{r}
# install.packages("bigsnpr") # run this if its your first time using this package
library(bigsnpr)
library(bigstatsr) # a useful dependency
```



```{r read-plink}
# run the line below just once, to create the .rds and .bk files you need 
# Note: The function assumes that all the files have the same base filename, and differ only in their extension. 
# snp_readBed("data/penncath.bed")

# now, read in the data to your R session 
penncath <- snp_attach("data/penncath.rds")

# check out this bigSNP object 
str(penncath)
```


From here, `bigsnpr` has a lot of functions to help us prepare data for analysis -- these functions depend on you having [PLINK 1.9](https://www.cog-genomics.org/plink2) installed somewhere on your local machine. Go to that page, download the files, and save them on your computer (I keep files like this in `~/bin/`). In order to tell whether PLINK installed correctly and is ready to go, type `path/to/plink --version` on either the command line prompt or in 'Terminal' in RStudio, where you fill in the path with the path to where you saved the downloaded files. If things are working correctly, you will see a message that says something like `PLINK v1.90b6.26 64-bit (2 Apr 2022)` -- the `PLINK v1.9` is the key here. 

# Basic quality control steps 

Once you have PLINK installed, we can start with some simple quality control (QC) steps in `R`: 

### Chromosome check

One helpful first step when getting any genetic data is to address the question: what chromosomes are the SNPs on? In our data, we can see this in the `map` element of our `bigSNP` object: 

```{r}
penncath$map$chromosome |> table()
```

We notice here that (1) we do not have any sex chromosomes^[Recall that our example data represents humans; chromosomes are numbered differently in other organisms, so interpret the following comments in the context of the specific data you have], and (2) we do not have any chromosomes with numbers outside 1-23. Sometimes, SNPs with unknown chromosome are labeled with a chromosome of 0. Another [common convention](https://www.cog-genomics.org/plink/1.9/data#irreg_output) is to label mitochondrial variants as having chromosome '26'. This is an issue that can throw off later analysis, so be sure to examine what data you have represented in your PLINK files. 

### Missing data

Any SNP with a lot of missing data (i.e., many samples do not have data for that marker) is probably represented with questionable quality in our data; these poorly-captured SNPs are often excluded from analysis. Likewise, any sample with lots of missing data suggests that there may be issues with the processing of that sample. Looking at our genotype data (i.e., what is in our .bed file), we see that some of our SNPs have missing values. 

```{r}
class(penncath$genotypes) # note: this is a file-backed object
?bigstatsr::big_counts # handy function to summarize data 
# take a look at what this does 
big_counts(penncath$genotypes, ind.row = 1:10, ind.col = 1:10)
# summarize genotype data by *SNP*
snp_stats <- big_counts(penncath$genotypes)
dim(snp_stats) # 4th row has NA counts 
boxplot(snp_stats[4,]) 
summary(snp_stats[4,]) 
```

There are definitely some SNPs with lots of missing values -- at least one SNP is missing across all 1,401 samples! A common practice is to exclude SNPs with >5% or >10% missing data. We'll actually do the subsetting a little later, right now we're just exploring.

We also need to consider any samples that have high proportions of missing values: 

```{r}
# summarize genotype data by *sample* 
sample_stats <- big_counts(penncath$genotypes, byrow = TRUE)
# cell [1,1] is showing the # of people with "0" genotype at the 1st SNP
sample_stats[, 1:10]
boxplot(sample_stats[4,])
summary(sample_stats[4,])
```

We notice that there are no outlier values in the number of NA values per person -- if there were outliers, we would need to filter out samples that have a high proportion of missing data. 

### Heterozygosity check 

If an individual had a ton of A/B calls but no A/A or B/B calls, or vice versa, that would likely indicate something was wrong in that sample -- we would typically expect all samples to have some heterozygous calls and some homozygous calls. 

```{r zygosity}
allele_dat <- sweep(x = sample_stats[1:3,], 
                    # ^ leave off 4th row -- don't count NAs here
                    MARGIN = 1,
                    STATS = c(0, 1, 0),
                    FUN = "*") |> colSums()

boxplot(allele_dat/ncol(snp_stats))
hist(allele_dat/ncol(snp_stats),
     main = "Zygosity",
     xlab = "Proportion of samples which are heterozygous") # should be bell-curved shaped
```

No big outliers here... that's a good sign.

### Minor allele frequency (MAF) filtering

As a first step, let's look at which SNPs have minor alleles that occur very rarely -- in a typical GWAS, we will need to exclude SNPs that have low variation. We see there are some SNPs for which all 1401 samples have the A/A alleles, or the major/major alleles. For analysis purposes, we typically need to exclude such SNPs in which variation is rare.

```{r}
hist(snp_stats[1,])
summary(snp_stats[1,])
```

### Hardy-Weinberg equilibrium filtering

< Will come back here >

### Relatedness check

In summary, here are the basic QC steps that (almost) all GWAS need to consider: 

- We need to filter out SNPs that have a really low minor allele frequency

- We need to filter out SNPs that have a lot of missing values (e.g., SNPs that a large proportion of observations/samples do not have recorded)

- We need to fileter out samples that have a lot of missing values (e.g., samples that had poor quality in upstream data collection/analysis)

- We need to filter out SNPs that are not in Hardy-Weinberg equilibrium 

- For simplicity, we want to examine autosomes only (no sex chromosomes), so we need to filter out data down to just SNPs from chromosomes 1-22

We can do all of these steps in one command below: 

```{r}
path_to_qc_penncath <- snp_plinkQC(
  plink.path = "~/bin/plink", # you will need to change this according to your machine!
  prefix.in = "data/penncath_clean",
  prefix.out = "data/qc_penncath",
  maf = 0.01, # filter out SNPs with MAF < 0.01
  geno = 0.1, # filter out SNPs missing more than 10% of data
  mind = 0.1, # filter out SNPs missing more than 10% of data,
  hwe = 1e-10, # filter out SNPs that have p-vals below this threshold for HWE test
  autosome.only = TRUE # we want chromosomes 1-22 only
)
```

The command above is a wrapper for PLINK, and so it will print out messages to the console, so you can follow along with what PLINK is doing. "Under the hood", PLINK is applying all the filters we want and creating a new set of bed/bim/fam files with the prefix "qc_penncath." We will use these QC'd files in our upcoming analysis. 

# Advanced quality control steps


# ---- OLD ---------

# Quality control

The first step in any GWAS is to examine the data for potential problems. You don't want to carry out a GWAS, think you have an exciting result, then discover that it was all just an artifact of bad data. This is a fairly "clean" data set, so it's not really ideal for showing these steps, but I'll go through them anyway. There is also a sample data set in the `snpStats` package with some (at least one) bad samples; might be worth checking that one out as well.

```{r snpstats-data}
data(for.exercise)
snps.10
```

Most of these QC steps involve calculating summaries at the individual ("row") level or the SNP ("column") level:

```{r summaries}
rs <- row.summary(obj$genotypes)
cs <- col.summary(obj$genotypes)
ggbox <- function (X, xlab = "ind", ylab = "values") {
    if (!is.data.frame(X)) X <- as.data.frame(X)
    ggplot2::ggplot(utils::stack(X), ggplot2::aes_string("ind", 
        "values")) + ggplot2::geom_boxplot() + ggplot2::xlab(xlab) + 
        ggplot2::ylab(ylab)
}
```

I'm also defining a little shortcut function for box plots.


## Minor allele frequency

Minor allele frequency is the percent of alleles that belong to less common category. For example:

```{r maf-example}
(Tab <- table(as(obj$genotypes[,143], 'numeric')))
(2*Tab[1] + Tab[2]) / (2*sum(Tab))
cs[143,]$MAF
```

Excluding SNPs on the basis of minor allele frequency is a bit controversial. It's done, and it makes sense, but has nothing to do with quality control -- there is no reason to think there are any errors in the data. The main justification is statistical:

* If MAF is low, power is low (i.e., don't spend multiple testing corrections on tests that are unlikely to find anything anyway)
* Some statistical methods perform badly with low MAF (e.g., the $chi^2$-test)

An appropriate cutoff definitely depends on sample size -- the larger the sample, the greater your ability to include rare SNPs. Let's look at the distributon of MAFs:

```{r maf}
hist(cs$MAF, breaks=seq(0, 0.5, 0.01), border='white', col='gray', las=1)
```

With a sample size of `r nrow(obj$genotypes)`, I would say a reasonable MAF would be something like 0.001 (0.1%).

```{r maf-exclude}
# How many SNPs would this exclude?
table(cs$MAF < 0.001)
# Would we really learn anything from analyzing a SNP like this?
table(as(obj$genotypes[,62], 'numeric'))
```

Finally, it is worth noting that no matter what the sample size, monomorphic SNPs (i.e., SNPs that show no genetic variation whatsoever in the sample) are usually problematic and should always be removed. Some code crashes when monomorphic SNPs are included; even if this weren't the case, these SNPs cannot possibly be informative in a genome-wide association study.

```{r monomorph}
table(cs$MAF == 0)                 # >26000 monomorphic SNPs
obj$map[head(which(cs$MAF==0)),]   # Note that "allele.1' is missing for these SNPs
```

## Sex check

In general, since we have genetic data on the individuals in the sample, including the X chromosome, we can determine (or at least, estimate) their "genetic sex" and compare that to the sex that is recorded in their clinical information. A discrepancy is very troubling, as it may be the result of a sample being switched or mis-labeled (there are other explanations as well).

Unfortunately, this data set does not include the X chromosome, so we can't show that step here.

In general, though, one usually uses PLINK for this. The relevant command is called `--check-sex`. The relevant documentation: [1.9 documentation](https://www.cog-genomics.org/plink/1.9/basic_stats#check_sex).

Note that there are no discrepancies between the sex recorded in `clinical.csv` and the one recorded in the `.fam` file:

```{r check-sex}
table(obj$fam$sex, clinical$sex)
```

## Hardy-Weinberg equilibrium

The [Hardy-Weinberg principle](https://en.wikipedia.org/wiki/Hardy-Weinberg_principle) states that under the assumption of random mating, the distribution of genotypes should follow a binomial distribution with probability $\pi$ equal to the MAF. If this doesn't happen, this is an indication that either:

1. There was a genotyping error for this SNP, or
2. Mating is not random

In the real world, mating is of course not random, making it difficult to exclude SNPs on the basis of HWE. The usual recommendation is to exclude a SNP only if HWE is hugely violated (e.g., $p < 10^{-10}$ for a test of whether the data follow a binomial distribution).

```{r hwe}
ggbox(cs$z.HWE)  # Mostly near zero, but some huge outliers
p_hwe <- 2*pnorm(-abs(cs$z.HWE))
table(p_hwe < 10^(-10))
# This seems utterly bizarre -- why would there be so many A/B's, but
# no A/A's or B/B's?  Something is definitely wrong:
table(as(obj$genotypes[,which.max(cs$z.HWE)], 'character'))
```




## Relatedness

Another common QC check that people apply is to see whether anyone in their data set is related to each other (i.e., their genomes are far more similar than the genomes of two unrelated people). This makes sense, as most statistical methods assume independent samples and if you have, say, two sisters in the analysis, they're not really independent. However, the tools for assessing relatedness are related to methods for assessing population structure, which is a complex topic that I'll discuss in the 'structure' module of the tutorial.

## Pipeline

OK, now that we've surveyed all these QC concepts, let's actually do some filtering. I might choose to do something like this:

```{r qc-pipe}
keep <- cs$MAF > 0.001 &
  cs$Call.rate > 0.9 &
  abs(cs$z.HWE) < 6.5
table(keep)
```

So, we're getting rid of about 100,000 SNPs and keeping about 750,000.

Now, let's actually do the subsetting. **IMPORTANT:** The key thing to remember here is that you need to subset both the `map` object and the genotypes -- if you don't, these objects will no longer match and you will end up with a devastating row mismatch problem.

```{r subset-1}
(obj$genotypes <- obj$genotypes[, keep])
obj$map <- obj$map[keep, ]
```

In principle, we might also be throwing some subjects out at this point, but in this particular example, none of the subjects looked questionable. Again, if throwing away subjects, you need to remember to also subset the `fam` object and the clinical data table.

Let's save this QC'd data set for future use in downstream analyses:

```{r save, eval=FALSE}
saveRDS(obj, 'data/gwas-qc.rds')
```
