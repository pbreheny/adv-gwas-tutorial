---
title: 'GWAS tutorial: Data formats, summary statistics, and quality control'
author: Patrick Breheny and Tabitha Peter 
date: '`r format(Sys.Date(), "%B %d, %Y")`'
editor_options: 
  chunk_output_type: console
---

```{r knitr_setup, include=FALSE, purl=FALSE}
library(knitr)
library(kableExtra)
set.seed(1)
knitr::opts_knit$set(aliases=c(h = 'fig.height', w = 'fig.width'))
knitr::opts_chunk$set(comment="#", message=FALSE, collapse=TRUE, cache=FALSE, tidy=FALSE, fig.align="center")
knitr::knit_hooks$set(small.mar = function(before, options, envir) {
  if (before) par(mar = c(4, 4, .1, .1))
})
```

`R` packages we need to get started 

```{r}
library(data.table)
library(dplyr)
library(ggplot2)
```


Throughout, I'm going to use the `data.table` package to read in and work with data frames; feel free to use something else. With one exception, the files are just white space delimited text files, anything can open them.

# Getting the data

This tutorial will use data from the PennCATH study of genetic risk factors for coronary artery disease. Download the data from one of the following sources (the contents are the same):

- [Data (zip)](https://d1ypx1ckp5bo16.cloudfront.net/penncath/penncath.zip): Windows
- [Data (tar)](https://d1ypx1ckp5bo16.cloudfront.net/penncath/penncath.tar.gz): Mac/Linux

Download and unzip/untar the data; you can read the paper as well if you wish:

* [Paper](http://www.ncbi.nlm.nih.gov/pubmed/21239051)

In what follows, I will assume that the unzipped data files are in a folder called `data`; if you store them somewhere else, change the directory references.

# File formats

The data are given in "PLINK" format, which is the most common format for chip-based GWAS data (as of this writing). `PLINK` is an open-source whole genome association analysis toolset designed to perform a range of basic large-scale analyses in a computationally efficient manner. As part of the toolset, PLINK has its own file formats -- again, these have become the standard format in the GWAS field. Data stored in PLINK format come in 'bundles' -- that is, a PLINK data set consists of a set of files, not just one data file. It is worth knowing how to use the PLINK command line tool to analyze data in these files, but those with no experience on the command line may find that a daunting place to begin. Thankfully, we can also interface with `PLINK` via `R`. The package we will use for this is [bigsnpr](https://privefl.github.io/bigsnpr/).

Let's take a look at the PLINK file structure, examining what information is stored in each file. 

Among the zipped files are three that are necessary to perform a GWAS, the `.bed`, `.bim`, and `.fam` files.

## `.fam`

This contains information on the subjects:

```{r fam}
head(fam <- fread('data/penncath.fam'))
```

There are 1401 rows, one for each subject. The six colums are:

1. Family ID
2. Individual ID
3. Paternal ID
4. Maternal ID
5. Sex (1=male; 2=female; other=unknown)
6. Phenotype

In this data set, columns 2-4 are unimportant. In general, they are used to specify pedigrees (e.g., subject 3 is the daughter of subjects 1 and 2). In this study, however, none of the subjects are related, so the only column that is important is the first, which records the subject's unique ID.

Phenotype is typically used to record case-control status or something like that, but it is also quite common to just record clinical/biological information in a separate spreadsheet, which is what was done here.

```{r clinical}
(clinical <- fread('data/penncath.csv'))
```

As you can see, we've got the `FamID` to match this spreadsheet up with the genetic data, the disease status (`CAD=1` means that the subject has coronary artery disease), and some covariates (age, triglycerides, HDL and LDL cholesterol levels).

## `.bim`

The `.bim` file, by contrast, contains information on the genetic loci (SNPs):

```{r bim}
bim <- fread('data/penncath.bim')
head(bim)
```

As you can see, we have `r nrow(bim)` rows here, one for each SNP measured in the study. The columns are:

1. chromosome (1-22, X, Y or 0 if unplaced)
2. rs# or snp identifier
3. Genetic distance (morgans)
4. Base-pair position (bp units)
5. Allele 1 (usually minor allele, or 'effect' allele)
6. Allele 2 (usually major allele)

It is pretty common for column 3 to be ignored, as it is here. Many common analyses do not require base-pair position. 

So, for example, the file tells us that genetic locus rs12565286 is located 721290 bases into chromosome 1, and that most people have a C there, but some have a G. Of course, "most people" will be relative to a population -- be sure to confirm with collaborators that you have a correct understanding of which allele is considered 'minor', and what population(s) are described in the data. More on the idea of 'population structure' to come in a later module. 

## `.bed`

Finally, the `.bed` file, which has all the data. This is by far the largest of the three files, as it contains the entire `r nrow(fam)` by `r nrow(bim)` matrix of genotype calls for every subject and every locus. To keep things manageable, this file is encoded in a special binary format -- i.e., you can't just open the file in a text editor or load it with something like `fread()`. That said, we can convert our PLINK data into a `bigSNP` object (defined in `bigsnpr`) -- this will let us look at our data in our `R` session. 


```{r}
# install.packages("bigsnpr") # run this if its your first time using this package
library(bigsnpr)
library(bigstatsr) # a useful dependency of bigsnpr
```

To read this into `R`, run the following chunk **only once**. This will create the .rds and .bk files you need, in the same directory where you've stored the `penncath.bed` (my directory is called `data/`)

```{r read-plink, eval=FALSE}
# Note: The function assumes that all the files have the same base filename, and differ only in their extension. 

snp_readBed("data/penncath.bed")
```

Now, read in the data to your R session 
```{r}
penncath <- snp_attach("data/penncath.rds")

# check out this bigSNP object 
str(penncath)
```

From here, `bigsnpr` has a lot of functions to help us prepare data for analysis -- these functions depend on you having [PLINK 1.9](https://www.cog-genomics.org/plink2) installed somewhere on your local machine. Go to that page, download the files, and save them on your computer (I keep files like this in `~/bin/`). In order to tell whether PLINK installed correctly and is ready to go, type `path/to/plink --version` on either the command line prompt or in 'Terminal' in RStudio, where you fill in the path with the path to where you saved the downloaded files. If things are working correctly, you will see a message that says something like `PLINK v1.90b6.26 64-bit (2 Apr 2022)` -- the `PLINK v1.9` is the key here. 

Note: in PLINK files, missing values are often recorded as "-9" - the `bigsnpr` package follows this convention as well. This is what you will see in the 'map' element of the `bigSNP` object -- where allele codes are missing, "-9" is inserted. 

# Basic quality control steps 

Once you have PLINK installed, we can start with some simple quality control (QC) steps in `R`: 

### Chromosome check

One helpful first step when getting any genetic data is to address the question: what chromosomes are the SNPs on? In our data, we can see this in the `map` element of our `bigSNP` object: 

```{r}
penncath$map$chromosome |> table()
```

We notice here that (1) we do not have any sex chromosomes^[Recall that our example data represents humans; chromosomes are numbered differently in other organisms, so interpret the following comments in the context of the specific data you have], and (2) we do not have any chromosomes with numbers outside 1-23. Sometimes, SNPs with unknown chromosome are labeled with a chromosome of 0. Another [common convention](https://www.cog-genomics.org/plink/1.9/data#irreg_output) is to label mitochondrial variants as having chromosome '26'. This is an issue that can throw off later analysis, so be sure to examine what data you have represented in your PLINK files. 

### Missing data

Any SNP with a lot of missing data (i.e., many samples do not have data for that marker) is probably represented with questionable quality in our data; these poorly-captured SNPs are often excluded from analysis. Likewise, any sample with lots of missing data suggests that there may be issues with the processing of that sample. Looking at our genotype data (i.e., what is in our .bed file), we see that some of our SNPs have missing values. 

```{r}
class(penncath$genotypes) # note: this is a file-backed object
?bigstatsr::big_counts # handy function to summarize data 
# take a look at what this does 
big_counts(penncath$genotypes, ind.row = 1:10, ind.col = 1:10)
# summarize genotype data by *SNP*
snp_stats <- big_counts(penncath$genotypes)
dim(snp_stats) # 4th row has NA counts 
boxplot(snp_stats[4,]) 
summary(snp_stats[4,]) 
```

There are definitely some SNPs with lots of missing values -- at least one SNP is missing across all 1,401 samples! A common practice is to exclude SNPs with >10% missing data. We'll actually do the subsetting a little later, right now we're just exploring.

We also need to consider any samples that have high proportions of missing values: 

```{r}
# summarize genotype data by *sample* 
sample_stats <- big_counts(penncath$genotypes, byrow = TRUE)
# cell [1,1] is showing the # of people with "0" genotype at the 1st SNP
sample_stats[, 1:10]
boxplot(sample_stats[4,])
summary(sample_stats[4,])
```

We notice that there are no outlier values in the number of NA values per person -- if there were outliers, we would need to filter out samples that have a high proportion of missing data. 

### Heterozygosity check 

If an individual had a ton of A/B calls but no A/A or B/B calls, or vice versa, that would likely indicate something was wrong in that sample -- we would typically expect all samples to have some heterozygous calls and some homozygous calls. 

```{r zygosity}
allele_dat <- sweep(x = sample_stats[1:3,], 
                    # ^ leave off 4th row -- don't count NAs here
                    MARGIN = 1,
                    STATS = c(0, 1, 0),
                    FUN = "*") |> colSums()

boxplot(allele_dat/ncol(snp_stats))
hist(allele_dat/ncol(snp_stats),
     main = "Zygosity",
     xlab = "Proportion of samples which are heterozygous") # should be bell-curved shaped
```

No big outliers here... that's a good sign.

### Minor allele frequency (MAF) filtering

As a first step, let's look at which SNPs have minor alleles that occur very rarely -- in a typical GWAS, we will need to exclude SNPs that have low variation. We see there are some SNPs for which all 1401 samples have the A/A alleles, or the major/major alleles. For analysis purposes, we typically need to exclude such SNPs in which variation is rare.

```{r}
hist(snp_stats[1,])
summary(snp_stats[1,])
```

The histogram and summary shows that there are some SNPs for which few, if any, samples have a minor allele. We will need to filter out these rare variants. 

### Hardy-Weinberg equilibrium filtering

The [Hardy-Weinberg principle](https://en.wikipedia.org/wiki/Hardy-Weinberg_principle) states that under the assumption of random mating, the distribution of genotypes should follow a binomial distribution with probability $\pi$ equal to the MAF. If this doesn't happen, this is an indication that either:

1. There was a genotyping error for this SNP, or
2. Mating is not random

In the real world, mating is of course not random, making it difficult to exclude SNPs on the basis of HWE. The usual recommendation is to exclude a SNP only if HWE is hugely violated (e.g., $p < 10^{-10}$ for a test of whether the data follow a binomial distribution). We will use this filter as a criteria.

### Relatedness check

Another common QC check that people apply is to see whether anyone in their data set is related to each other (i.e., their genomes are far more similar than the genomes of two unrelated people). This makes sense, as most statistical methods assume independent samples and if you have, say, two sisters in the analysis, they're not really independent. However, the tools for assessing relatedness are related to methods for assessing population structure, which is a complex topic that I'll discuss in the ['structure' module](docs/population_structure.html) of the tutorial.


### Summary & implementation
In summary, here are the basic QC steps that (almost) all GWAS need to consider: 

(1) We need to check the chromosomes we have represented in our data

(2) We need to filter out samples that have a lot of missing values (e.g., samples that had poor quality in upstream data collection/analysis)

(3) We need to check for heterozygosity, and filter out samples that are clear outliers

(4) We need to filter out SNPs that have a really low minor allele frequency

(5) We need to filter out SNPs that are far outside Hardy-Weinberg equilibrium 

(6) We need to consider relatedness in our data -- both the relatedness that is known as well as any latent relationship structure(s).

We can do steps (1), (2), (4), and (5) in one command below: 

```{r, eval=FALSE}
path_to_qc_penncath <- snp_plinkQC(
  plink.path = "~/bin/plink", # you will need to change this according to your machine!
  prefix.in = "data/penncath", # creates *new* rds with quality-controlled data
  prefix.out = "data/qc_penncath",
  maf = 0.01, # filter out SNPs with MAF < 0.01
  geno = 0.1, # filter out SNPs missing more than 10% of data
  mind = 0.1, # filter out SNPs missing more than 10% of data,
  hwe = 1e-10, # filter out SNPs that have p-vals below this threshold for HWE test
  autosome.only = TRUE # we want chromosomes 1-22 only
)
```

The command above is a wrapper for PLINK, and so it will print out messages to the console, so you can follow along with what PLINK is doing. "Under the hood", PLINK is applying all the filters we want and creating a new set of bed/bim/fam files with the prefix "qc_penncath." We will use these QC'd files in our upcoming analysis. 

Step (3) we have done by visual inspection -- in this data set, that is all we need. Step (6) requires quite a bit of explanation, so this step has [its own module](docs/population_structure.html) in this tutorial. 

So, we're getting rid of about 100,000 SNPs and keeping about 750,000.

Now, let's actually do the subsetting. **IMPORTANT:** The key thing to remember here is that when you subset genetic data in PLINK files, you need to subset both the `map` object and the genotypes -- if you don't, these objects will no longer match and you will end up with a devastating row mismatch problem. If you are using `PLINK` (any version) on the command line or `bigsnpr` in `R`, then this is automatically taken care of for you. However, if you are reading in the .bim/.fam files as data frames (as we did at the beginning), then you would need to make sure you subset both files. 

Let's look at our new `RDS` object, the one we just created using our QC steps: 

```{r}
qc <- snp_attach("path_to_qc_penncath.rds")
```


Using our QC'd data in `qc_penncath`, we will continue in the next section with [imputation](docs/imputation.html)

### Note on memory issues 

One of the great features about the `bigSNP` objects in `bigsnpr` is that these objects save the large genotype data (i.e., what's in the .bed PLINK file) as file-backed -- in layman's terms, file-backed objects let you have an object in your global environment that is 'pointing at' the large data file stored on disk. If you want to read genotype data from just a few SNPs into memory, we can do this:

```{r}
# notice: data are file backed 
class(penncath$genotypes)

# read in just a few SNPs 
first_10_snps <- penncath$genotypes[,1:10]

# these are now stored in memory as a matrix 
class(first_10_snps); dim(first_10_snps)

# take a look at this
head(first_10_snps)
```

# Advanced quality control steps

## Sex check

In general, since we have genetic data on the individuals in the sample, including the X chromosome, we can determine (or at least, estimate) their "genetic sex" and compare that to the sex that is recorded in their clinical information. A discrepancy is very troubling, as it may be the result of a sample being switched or mis-labeled (there are other explanations as well).

Unfortunately, this data set does not include the X chromosome, so we can't show that step here.

In general, though, one usually uses PLINK for this. The relevant command is called `--check-sex`. The relevant documentation: [1.9 documentation](https://www.cog-genomics.org/plink/1.9/basic_stats#check_sex).

Note that there are no discrepancies between the sex recorded in `clinical.csv` and the one recorded in the `.fam` file:

```{r check-sex}
table(penncath$fam$sex, clinical$sex)
```

In our data, this is sufficient for us to know we are good to go. 

## Pruning, clumping, and LD filtering 

SNPs which are close to one another in base-pair position are often in [linkage disequilibrium](https://www.sciencedirect.com/topics/neuroscience/linkage-disequilibrium#:~:text=Linkage%20disequilibrium%2C%20the%20phenomenon%20whereby,proxy%20for%20the%20risk%20variant.) (LD) with each other -- we say, 'the SNPs are in LD'. When SNPs are in LD, this can have a notable impact on analysis, particularly when the approach is a marginal analysis (i.e., testing one SNP at a time). [Florian Privé](https://privefl.github.io/), author of the `bigstatsr` and `bigsnpr` packages, has written some good [vignettes](https://privefl.github.io/bigsnpr/articles/pruning-vs-clumping.html) on how and when to use pruning/clumping as a QC step to address LD. For now, I refer you there -- I hope to do some of my own writing on the subject one day. 
